<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Olivier Binette">
<meta name="dcterms.date" content="2019-04-10">
<meta name="description" content="A sound re-interpretation of the adjusted R^2 value for model comparison.">

<title>The Significance of the adjusted R squared coefficient – Olivier Binette</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "Search",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-059GDHV0GP"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-059GDHV0GP', { 'anonymize_ip': false});
</script>
<style>

      .quarto-title-block .quarto-title-banner h1,
      .quarto-title-block .quarto-title-banner h2,
      .quarto-title-block .quarto-title-banner h3,
      .quarto-title-block .quarto-title-banner h4,
      .quarto-title-block .quarto-title-banner h5,
      .quarto-title-block .quarto-title-banner h6
      {
        color: #c00000;
      }

      .quarto-title-block .quarto-title-banner {
        color: #c00000;
background: #f8f8f8;
      }
</style>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<meta property="og:title" content="The Significance of the adjusted R squared coefficient – Olivier Binette">
<meta property="og:description" content="A sound re-interpretation of the adjusted \(R^2\) value for model comparison.">
<meta property="og:site_name" content="Olivier Binette">
<meta name="twitter:title" content="The Significance of the adjusted R squared coefficient – Olivier Binette">
<meta name="twitter:description" content="A sound re-interpretation of the adjusted \(R^2\) value for model comparison.">
<meta name="twitter:card" content="summary">
</head>

<body class="floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">Olivier Binette</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../pages/blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-creations" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Creations</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-creations">    
        <li>
    <a class="dropdown-item" href="../../../pages/research.html">
 <span class="dropdown-text">Publications</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../pages/software.html">
 <span class="dropdown-text">Software</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.github.com/OlivierBinette"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../../pages/blog.xml"> <i class="bi bi-rss" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default toc-left page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">The Significance of the adjusted R squared coefficient</h1>
                  <div>
        <div class="description">
          <p>A sound re-interpretation of the adjusted <span class="math inline">\(R^2\)</span> value for model comparison.</p>
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">technical</div>
                <div class="quarto-category">statistics</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">April 10, 2019</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#model-and-notations" id="toc-model-and-notations" class="nav-link active" data-scroll-target="#model-and-notations">Model and notations</a></li>
  <li><a href="#testing-for-an-increase-of-r2_a" id="toc-testing-for-an-increase-of-r2_a" class="nav-link" data-scroll-target="#testing-for-an-increase-of-r2_a">Testing for an increase of <span class="math inline">\(R^2_a\)</span></a>
  <ul class="collapse">
  <li><a href="#a-dual-perspective-on-nested-model-comparison" id="toc-a-dual-perspective-on-nested-model-comparison" class="nav-link" data-scroll-target="#a-dual-perspective-on-nested-model-comparison">A Dual perspective on nested model comparison</a></li>
  <li><a href="#some-precisions" id="toc-some-precisions" class="nav-link" data-scroll-target="#some-precisions">Some precisions</a></li>
  <li><a href="#reinterpretation-under-gaussian-hypotheses" id="toc-reinterpretation-under-gaussian-hypotheses" class="nav-link" data-scroll-target="#reinterpretation-under-gaussian-hypotheses">Reinterpretation under Gaussian hypotheses</a></li>
  <li><a href="#relationship-with-fishers-f-test" id="toc-relationship-with-fishers-f-test" class="nav-link" data-scroll-target="#relationship-with-fishers-f-test">Relationship with Fisher’s <span class="math inline">\(F\)</span>-test</a></li>
  </ul></li>
  <li><a href="#discussion" id="toc-discussion" class="nav-link" data-scroll-target="#discussion">Discussion</a></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>My friend <a href="https://anthonycoache.ca/">Anthony Coache</a> and I have been curious about uses and misuses of the <em>adjusted</em> <span class="math inline">\(R^2\)</span> coefficient which comes up in linear regression for model comparison and as a measure of “goodness of fit”. We were underwhelmed by the depth of the literature arguing for its use, and wanted to show exactly how it behaves under certain sets of assumptions. Investigating the issue brought us to re-interpret the adjusted <span class="math inline">\(R^2\)</span> and to highlight a new distribution-free perspective on nested model comparison which is equivalent, under Gaussian assumptions, to Fisher’s classical <span class="math inline">\(F\)</span>-test. This generalizes to nested GLMs comparison and provides exact comparison tests that are not based on asymptotic approximations. We still have many questions to answer, but here’s some of what we’ve done.</p>
<!--more-->
<p>So, in the context of least squares linear regression, the model for relating a vector of <span class="math inline">\(n\)</span> observed responses <span class="math inline">\(Y\)</span> to <span class="math inline">\(p-1\)</span> independent covariates is <span class="math inline">\(Y = X \beta + \varepsilon\)</span>, where <span class="math inline">\(X\)</span> is the design matrix and <span class="math inline">\(\varepsilon\)</span> is the vector of random errors. One of many summary statistics arising from data analyses based on this model is the adjusted <span class="math inline">\(R^2\)</span> coefficient, defined as</p>
<p><span class="math display">\[R^2_a(Y, X) = 1 - \frac{\|\hat \varepsilon\|^2}{\left\|Y - \bar Y \right\|^2}\frac{n-1}{n-p},\]</span></p>
<p>where <span class="math inline">\(\hat \varepsilon\)</span> is the vector of residual errors and <span class="math inline">\(\bar Y\)</span> is the mean of <span class="math inline">\(Y\)</span> (Cramer, 1987; Ohtani, 2004). The <span class="math inline">\(R^2\)</span> coefficient and its adjusted counterpart are widely used as measures of goodness of fit, as model selection criteria and as estimators of the squared multiple correlation coefficient <span class="math inline">\(\rho^2\)</span> of the parent population. While their properties have been thoroughly studied in these contexts (Olkin, 1958; Helland, 1987; Cramer, 1987; Meepagala, 1992; Ohtani, 2004), the literature is scarce in explanations as to what, exactly, <span class="math inline">\(R^2_a\)</span> adjusts for in non-trivial cases. It is not an unbiased estimator of <span class="math inline">\(\rho^2\)</span> and the <em>degrees of freedom adjustment</em> heuristic (Theil, 1971) is of limited depth.</p>
<p>Here we show in what sense the adjusted <span class="math inline">\(R^2\)</span> coefficient may be considered “unbiased”. For nested models comparison, we also suggest how to test the significance of a <span class="math inline">\(R^2_a\)</span> difference between two nested models which is equivalent to Fisher’s <span class="math inline">\(F\)</span>-test under Gaussian assymptions. The <span class="math inline">\(R^2_a\)</span> test is however done from a largely distribution-free perspective which is conditional on the observation of <span class="math inline">\(Y\)</span>. The results are then reinterpreted under classical Gaussian assumptions, which emphasize the dual perspectives between those two tests.</p>
<section id="model-and-notations" class="level3">
<h3 class="anchored" data-anchor-id="model-and-notations">Model and notations</h3>
<p>Given a matrix <span class="math inline">\(A\)</span>, let <span class="math inline">\(\text{Span}(A)\)</span> denote the subspace spanned by its columns and <span class="math inline">\(P_A\)</span> be the (orthogonal) projection on <span class="math inline">\(\text{Span}(A)\)</span>.</p>
<p>The commonly used linear regression model is <span class="math display">\[Y = X \beta + \varepsilon,\]</span> where <span class="math inline">\(Y\)</span> is a <span class="math inline">\(n \times 1\)</span> vector of observed responses, the design matrix <span class="math inline">\(X\)</span> consists of a constant column vector followed by <span class="math inline">\(p-1\)</span> column vectors of covariates, <span class="math inline">\(\beta\)</span> is the vector of parameters to be estimated and <span class="math inline">\(\varepsilon\)</span> is the vector of random errors. The fixed design matrix is supposed to be non-random and of full rank <span class="math inline">\(p\)</span>. Let also <span class="math inline">\(\hat \varepsilon = Y - P_X Y\)</span> denote the residuals errors obtained by linear least squares fitting.</p>
</section>
<section id="testing-for-an-increase-of-r2_a" class="level2">
<h2 class="anchored" data-anchor-id="testing-for-an-increase-of-r2_a">Testing for an increase of <span class="math inline">\(R^2_a\)</span></h2>
<p>Suppose we have two design matrices <span class="math inline">\(X\)</span> and <span class="math inline">\(\tilde X\)</span>, where <span class="math inline">\(\text{Span}(X) \subset \text{Span}(\tilde X)\)</span>. Let <span class="math inline">\(p=\text{rank}(X)\)</span> and <span class="math inline">\(\tilde p = \text{rank}(\tilde X) = p+k\)</span>. Given the vector of observations <span class="math inline">\(Y\)</span>, we observe two values <span class="math inline">\(R^2 _ a (Y, X)\)</span> and <span class="math inline">\(R^2_ a (Y, \tilde X)\)</span> associated to the nested models. The classical way to test for a significant increase of <span class="math inline">\(R^2 _ a\)</span> is to carry out Fisher’s <span class="math inline">\(F\)</span>-test based on the statistics</p>
<p><span class="math display">\[
F = \frac{\| \hat Y_0 - \hat Y \|^2}{\| Y - \hat Y \|^2} \frac{n - \tilde p }{k},
\]</span></p>
<p>where <span class="math inline">\(\hat Y_0 = P_X Y\)</span> and <span class="math inline">\(\hat Y = P_ {\tilde X}Y\)</span>. This is a function of both <span class="math inline">\(R^2_a(Y, X)\)</span> and <span class="math inline">\(R^2_a(Y, \tilde X)\)</span>, which, under the assumption</p>
<p><span class="math display">\[
H_0: \quad Y = X \beta + \varepsilon
\]</span></p>
<p>for <span class="math inline">\(\varepsilon \sim N(0, \sigma^2 I_n)\)</span>, has an <span class="math inline">\(F\)</span>-distribution.</p>
<p>This is, however, a rather convoluted way of going about comparing the two numbers <span class="math inline">\(R^2_a(Y, X)\)</span> and <span class="math inline">\(R^2_a(Y, \tilde X)\)</span>. Can we do simpler, and can we drop the Gaussian assumption? The answer is yes, although we’ll have to change a bit our point of view on the problem.</p>
<section id="a-dual-perspective-on-nested-model-comparison" class="level3">
<h3 class="anchored" data-anchor-id="a-dual-perspective-on-nested-model-comparison">A Dual perspective on nested model comparison</h3>
<p>The whole point of nested model comparison is to see if the new covariates in <span class="math inline">\(\tilde X\)</span>, i.e.&nbsp;those that are not part of <span class="math inline">\(\text{Span}(X)\)</span>, bring new information about <span class="math inline">\(Y\)</span>. In the context of an exploratory analysis where the observations and predictors are all observed, we propose to change our perspective to the following testing procedure:</p>
<ol type="1">
<li>condition on the observation of <span class="math inline">\(Y\)</span> and <span class="math inline">\(X\)</span> (consider them fixed, observed values);</li>
<li>tests if the new covariates in <span class="math inline">\(\tilde X\)</span> are random noise.</li>
</ol>
<p>Hence, rather than testing the model <span class="math inline">\(Y = X\beta + \varepsilon\)</span> under a Gaussian noise assumption, we test for <em>covariate randomness</em>, our null hypothesis becomes</p>
<p><span class="math display">\[
H_0':\quad \text{the complement of $\text{Span}(X)$ in $\text{Span}(\tilde X)$ is a random subspace.}
\]</span></p>
<p>This test can be carried out using any test statistic <span class="math inline">\(T\)</span>, and obviously the distribution of <span class="math inline">\(T\)</span> under <span class="math inline">\(H_0'\)</span> (and conditionally on <span class="math inline">\(Y\)</span>), will not depend on the unknown parameter <span class="math inline">\(\beta\)</span> nor on the noise structure <span class="math inline">\(\varepsilon\)</span> (which has been conditionned out of randomness). In particular, we can take <span class="math inline">\(T = R^2_a(Y, \tilde X)\)</span>.</p>
<p>Does it make any sense? Well it does not change anything! The test obtained in this framework is entirely equivalent to Fisher’s <span class="math inline">\(F\)</span>-test we reviewed before: for any given observation of <span class="math inline">\(Y\)</span>, <span class="math inline">\(X\)</span> and <span class="math inline">\(\tilde X\)</span>, the two tests will give the same results.</p>
<p>Let me make all of this more precise.</p>
</section>
<section id="some-precisions" class="level3">
<h3 class="anchored" data-anchor-id="some-precisions">Some precisions</h3>
<p>Let <span class="math inline">\(\tilde X = [X \; W] \in \mathbb{R}^{n \times \tilde p}\)</span> be the concatenation of <span class="math inline">\(X\)</span> with a matrix <span class="math inline">\(W = [W_1 \, \cdots \, W_k]\)</span> of <span class="math inline">\(k\)</span> new covariates. The goal is to test whether or not <span class="math inline">\(R^2_a(Y, \tilde X)\)</span> has significantly increased from <span class="math inline">\(R^2_a(Y, X)\)</span>. Henceforth, we shall assume that both <span class="math inline">\(Y\)</span> and <span class="math inline">\(X\)</span> are fixed and the null hypothesis is</p>
<p><span class="math display">\[
H_0':\; \text{ the } W_i \text{ are independent and of uniformly distributed directions.}
\]</span></p>
<p>By saying that <span class="math inline">\(W_i\)</span> has a <em>uniformly distributed direction</em>, we mean that <span class="math inline">\(W_i/\|W_i\|\)</span> is uniformly distributed on the <span class="math inline">\(n\)</span>-sphere. This is satisfied, for instance, if <span class="math inline">\(W_i \sim N(0, \sigma_i^2 I_n)\)</span> and this represents the augmentation of the covariate space through random directions. It is equivalent to saying that the complement of <span class="math inline">\(\text{Span}(X)\)</span> in <span class="math inline">\(\text{Span}(\tilde X)\)</span> is a random subspace. The following proposition shows that the expected value of <span class="math inline">\(R^2_a(Y, \tilde X)\)</span> is invariant under the addition of such covariates and provides the distribution of <span class="math inline">\(R^2_a(Y, \tilde X)\)</span> under <span class="math inline">\(H_0'\)</span>.</p>
<p><strong>Proposition 1.</strong> Let <span class="math inline">\(Y \in \mathbb{R}^n\)</span> and <span class="math inline">\(X \in \mathbb{R}^{n \times p}\)</span> be fixed and let <span class="math inline">\(\tilde X = [X \; W_1 \, \cdots \, W_k]\)</span> be the concatenation of <span class="math inline">\(X\)</span> with <span class="math inline">\(k \leq n- p\)</span> independent random vectors <span class="math inline">\(W_1, \ldots, W_k\)</span> of uniformly distributed directions. Then</p>
<p><span class="math display">\[
\mathbb{E}\left[ R^2_a(Y, \tilde X) \right] = R^2_a(Y, X).
\]</span></p>
<p>and, more precisely, under <span class="math inline">\(H_0\)</span> we have that <span class="math inline">\(R^2_a(Y, \tilde X)\)</span> is distributed as</p>
<p><span class="math display">\[
1-  \frac{(n-1)\| \hat \varepsilon \|^2}{(n-\tilde p) \| Y - \bar Y \|^2}\text{Beta}\left(\tfrac{n-\tilde p}{2}, \tfrac{k}{2} \right)
\]</span></p>
<p>where <span class="math inline">\(\text{Beta}\left(\tfrac{(n-\tilde p)}{2}, \tfrac{k}{2} \right)\)</span> is a Beta random variable of parameters <span class="math inline">\((n-\tilde p)/2\)</span> and <span class="math inline">\(k/2\)</span>.</p>
<p><strong>Proof.</strong> Let <span class="math inline">\(\omega\)</span> be the projection of <span class="math inline">\([W_1 \, \cdots \, W_k]\)</span> on the orthogonal <span class="math inline">\(V\)</span> of <span class="math inline">\(\text{Span}(X)\)</span> and denote by <span class="math inline">\(P_\omega\)</span> the orthogonal projection onto <span class="math inline">\(V_\omega =  \text{Span}(\omega)\)</span>. By the Pythagorean theorem we have <span class="math inline">\(\|Y - P_ {\tilde X} Y \|^2 + \|P_\omega \hat \varepsilon\|^2 = \|\hat \varepsilon\|^2\)</span> and hence we may write</p>
<p><span class="math display">\[
    R^2_a(Y, \tilde X) = 1- \frac{(n-1)\|\hat \varepsilon\|^2}{(n-\tilde p) \left\| Y - \bar Y\right\|^2} \left(1 - \frac{\|P_\omega \hat \varepsilon\|^2}{\|\hat \varepsilon\|^2} \right).
\]</span></p>
<p>We now derive the distribution of <span class="math inline">\(\|P_\omega \hat \varepsilon\|^2/\|\hat \varepsilon\|^2\)</span>. This term is the squared norm of projection of the unit vector <span class="math inline">\(\hat \varepsilon / \|\hat \varepsilon\| \in V\)</span> on the random subspace <span class="math inline">\(V_\omega \subset V\)</span>. Let us now introduce a random unitary matrix <span class="math inline">\(U\)</span> obtained by orthonormalizing <span class="math inline">\(\dim(V) = n - p\)</span> random vectors of uniformly distributed directions, so that <span class="math inline">\(P_\omega \hat \varepsilon\)</span> is distributed as the first <span class="math inline">\(k\)</span> components of the vector <span class="math inline">\(U \hat \varepsilon\)</span>. Since <span class="math inline">\(U\hat \varepsilon / \|\hat \varepsilon\|\)</span> is uniformly distributed on the unit sphere of <span class="math inline">\(V\)</span>, it follows that the squared norm of its first <span class="math inline">\(k\)</span> components has a <span class="math inline">\(\text{Beta}(k/2, (n-\tilde p)/2)\)</span> distribution. In other words, we have shown that <span class="math inline">\(\|P_\omega \hat \varepsilon\|^2/\|\hat \varepsilon\|^2 \sim \text{Beta}\left(\tfrac{k}{2}, \tfrac{n-\tilde p}{2} \right)\)</span>.</p>
<p>The expectation of <span class="math inline">\(R^2_a(Y, \tilde X)\)</span> is obtained from this distributional expression. <span class="math inline">\(\Box\)</span></p>
</section>
<section id="reinterpretation-under-gaussian-hypotheses" class="level3">
<h3 class="anchored" data-anchor-id="reinterpretation-under-gaussian-hypotheses">Reinterpretation under Gaussian hypotheses</h3>
<p>While the preceding analysis was conditional on the observation of <span class="math inline">\(Y\)</span>, suppose now that <span class="math inline">\(Y = X \beta + \varepsilon\)</span>, where <span class="math inline">\(\varepsilon \sim N(0, \sigma^2)\)</span> for some <span class="math inline">\(\sigma^2 &gt; 0\)</span>. The distribution of <span class="math inline">\(R^2_a(Y, X)\)</span> is then intricately related to the unknown parameter <span class="math inline">\(\beta\)</span>, preventing a direct analysis.</p>
<p>However, as shown in Cramer (1987), the adjusted <span class="math inline">\(R^2\)</span> coefficient can still be understood as compensating for irrelevant covariates: in a correctly specified model, its expected value is invariant under the addition of covariates. This is formalized in Proposition 2 below. We preferred a more elementary proof than found therein, avoiding the rather involved explicit expression of the expected value that depends on the unknown parameter <span class="math inline">\(\beta\)</span>.</p>
<p><strong>Proposition 2.</strong> Suppose <span class="math inline">\(Y = X \beta + \varepsilon\)</span>, where <span class="math inline">\(\beta \in \mathbb{R}^{p}\)</span> and <span class="math inline">\(\varepsilon \sim N(0, \sigma^2 I_n)\)</span> is Gaussian noise. If <span class="math inline">\(\tilde X\)</span> is another design matrix of rank <span class="math inline">\(\tilde p\)</span> such that <span class="math inline">\(\text{Span}(X) \subset \text{Span}(\tilde X)\)</span>, then</p>
<p><span class="math display">\[
\mathbb{E}\left[ R^2_a(Y, \tilde X) \right] = \mathbb{E}\left[R^2_a(Y, X)\right].
\]</span></p>
<p><strong>Remark.</strong> More precisely, we know the conditional distribution of <span class="math inline">\(R^2_a(Y, \tilde X)\)</span> given <span class="math inline">\(R^2_a(Y, X)\)</span>: it is the same as the distribution which appears in the context of Proposition 1. The above results then follows from a simple computation.</p>
<p><strong>Proof.</strong> Let <span class="math inline">\(\hat \varepsilon^{*} = Y - P_ {\tilde X} Y\)</span> and write <span class="math inline">\(\lambda = \left\|\mathbb{E}\left[Y - \bar Y\right]\right\|^2/\sigma^2\)</span>. Then <span class="math inline">\(\frac{\|\hat \varepsilon^{*}\|^2}{\left\|Y - \bar Y\right\|^2}\)</span> is distributed as <span class="math display">\[
    \frac{\sum_ {i=1}^{n - \tilde p} Z_i^2}{\sum_ {i=1}^{n - \tilde p} Z_i^2 + \chi^2_ {\tilde p -1} (\lambda)}
\]</span></p>
<p>for independent <span class="math inline">\(Z_i \sim N(0,1)\)</span> and <span class="math inline">\(\chi^2_ {\tilde p - 1} (\lambda)\)</span> a noncentral <span class="math inline">\(\chi^2\)</span> random variable of parameter <span class="math inline">\(\lambda\)</span>. Hence</p>
<p><span class="math display">\[
\mathbb{E}\left[ \frac{\|\hat \varepsilon^{}\|^2}{\left\|Y - \bar Y\right\|^2} \right] = (n-\tilde p) \mathbb{E}\left[\frac{Z_1^2}{\sum{i=1}^{n - \tilde p} Z_i^2 + \chi^2{\tilde p -1} (\lambda)}\right]
    = (n-\tilde p)K,
\]</span></p>
<p>where <span class="math inline">\(K = \mathbb{E}\left[\frac{Z_1^2}{Z_1^2 + \chi^2_ {n - 2} (\lambda)}\right]\)</span> and <span class="math inline">\(\chi^2_ {n-2}(\lambda)\)</span> is a new and independent noncentral <span class="math inline">\(\chi^2\)</span> random variable. It follows that</p>
<p><span class="math display">\[
    \mathbb{E} \left[R^2_a(Y, \tilde X) \right] = 1 - (n-1)K
\]</span></p>
<p>depends on <span class="math inline">\(\tilde X\)</span> only through <span class="math inline">\(X\)</span> and must equal <span class="math inline">\(\mathbb{E} \left[R^2_a(Y, X) \right]\)</span>. <span class="math inline">\(\Box\)</span></p>
</section>
<section id="relationship-with-fishers-f-test" class="level3">
<h3 class="anchored" data-anchor-id="relationship-with-fishers-f-test">Relationship with Fisher’s <span class="math inline">\(F\)</span>-test</h3>
<p>In the context of Proposition 2, suppose in particular that <span class="math inline">\(\tilde X = [X \; W]\)</span>, where <span class="math inline">\(W = [W_1\, \cdots \, W_k]\)</span> is a matrix of additional fixed regressors. Recall that the <span class="math inline">\(F\)</span>-statistic for Fisher’s test with nested models of <span class="math inline">\(p\)</span> and <span class="math inline">\(\tilde p = p + k\)</span> parameters respectively is given by</p>
<p><span class="math display">\[
F = \frac{\| \hat Y_0 - \hat Y \|^2}{\| Y - \hat Y \|^2} \frac{n - \tilde p }{k},
\]</span></p>
<p>where <span class="math inline">\(\hat Y_0 = P_X Y\)</span> and <span class="math inline">\(\hat Y = P_{\tilde X} Y\)</span> are the vector of predicted values for the models corresponding to <span class="math inline">\(X\)</span> and <span class="math inline">\(\tilde X\)</span>. The test of significance devised in Section 2, based on <span class="math inline">\(R^2_a(Y, \tilde X)\)</span>, is then equivalent to Fisher’s <span class="math inline">\(F\)</span>-test of the hypothesis</p>
<p><span class="math display">\[
H_0^{\text{Gauss}}:\; Y = X\beta + \varepsilon\, \text{ where }\,\varepsilon \sim N(0, \sigma^2 I_n).
\]</span></p>
<p>To see this, let <span class="math inline">\(\omega\)</span> be, as in the proof of Proposition 1, the projection of <span class="math inline">\([W_1\,\cdots\,W_k]\)</span> on the orthogonal of <span class="math inline">\(\text{Span}(X)\)</span> and denote by <span class="math inline">\(P_\omega\)</span> the projection on <span class="math inline">\(\text{Span}(\omega)\)</span>. Then the <span class="math inline">\(F\)</span>-statistic can be written as</p>
<p><span class="math display">\[
    F = \frac{\|P_\omega \hat \varepsilon\|^2}{\|\hat \varepsilon - P_\omega \hat \varepsilon \|^2} \frac{n-\tilde p}{k} = \frac{\|P_\omega \hat \varepsilon\|^2/\|\hat \varepsilon\|^2}{1 - \|P_\omega \hat \varepsilon \|^2/\|\hat \varepsilon\|^2} \frac{n-\tilde p}{k}.
\]</span></p>
<p>This is a monotonous invertible transform of <span class="math inline">\(\|P_\omega \hat \varepsilon\|^2/\|\hat \varepsilon\|^2\)</span> which, under <span class="math inline">\(H_0^{\text{Gauss}}\)</span>, follows a Beta distribution of parameters <span class="math inline">\(k/2\)</span> and <span class="math inline">\((n-\tilde p)/2\)</span>. Yet in the framework of Section 2 and under <span class="math inline">\(H_0\)</span>, where now <span class="math inline">\(\omega\)</span> is random and <span class="math inline">\(\hat \varepsilon\)</span> fixed, the test statistic <span class="math inline">\(R^2_ a(Y, \tilde X)\)</span> is also a monotonous invertible function of <span class="math inline">\(\|P_ \omega \hat \varepsilon\|^2/\|\hat \varepsilon\|^2 \sim \text{Beta}(k/2, (n-\tilde p)/2)\)</span>. This shows that the two unilateral tests are equivalent: the same observations yield the same <span class="math inline">\(p\)</span>-values.</p>
</section>
</section>
<section id="discussion" class="level2">
<h2 class="anchored" data-anchor-id="discussion">Discussion</h2>
<p>We have highlighted dual perspectives on nested models comparison. An increase of <span class="math inline">\(R^2\)</span> may be due to random noise that correlates with fixed regressors, or to random regressors that correlate with fixed observations. Fisher’s test of the first hypothesis is equivalent to the <span class="math inline">\(R^2_a\)</span> test of the second. Furthermore, we showed that <span class="math inline">\(R^2_a\)</span> compensates properly, on the average, for both types of inflation of <span class="math inline">\(R^2\)</span>. We suggest this provides a clear explanation of what <span class="math inline">\(R^2_a\)</span> exactly adjusts for and how it can properly be used for models comparison.</p>
<p>Furthermore, the fact that random covariate tests, conditional on the observations, can be carried out exactly using any measure of goodness of fit (e.g.&nbsp;the likelihood or the AIC) suggests that our approach may be helpful in devising nested model comparison tests for GLMs. Testing at a chosen confidence level also provides more flexibility than using a rule-based procedure such as the AIC.</p>
<p><strong>References</strong></p>
<ul>
<li>Cramer, J. S. (1987). Mean and variance of r2 in small and moderate samples. <em>Journal of Econometrics 35(2)</em>, 253 – 266.</li>
<li>Helland, I. S. (1987). On the interpretation and use of r2 in regression analysis. <em>Biometrics 43(1)</em>, 61–69.</li>
<li>Meepagala, G. (1992). The small sample properties of r2 in a misspecified regression model with stochastic regressors. <em>Economics Letters 40(1)</em>, 1 – 6.</li>
<li>Ohtani, K. and H. Tanizaki (2004). Exact distributions of r2 and adjusted r2 ina linear regression model with multivariate t error terms. <em>Journal of the Japan Statistical Society 34(1)</em>, 101–109.</li>
<li>Olkin, I. and J. W. Pratt (1958). Unbiased estimation of certain correlation coefficients. <em>The Annals of Mathematical Statistics 29(1)</em>, 201–211.</li>
<li>Theil, H. (1971). <em>Principles of econometrics (1 ed.)</em>. New York: J. Wiley.</li>
</ul>


</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" id="quarto-reuse"><h2 class="anchored quarto-appendix-heading">Reuse</h2><div class="quarto-appendix-contents"><div><a rel="license" href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a></div></div></section><section class="quarto-appendix-contents" id="quarto-copyright"><h2 class="anchored quarto-appendix-heading">Copyright</h2><div class="quarto-appendix-contents"><div>Olivier Binette</div></div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/olivierbinette\.ca");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      const annoteTargets = window.document.querySelectorAll('.code-annotation-anchor');
      for (let i=0; i<annoteTargets.length; i++) {
        const annoteTarget = annoteTargets[i];
        const targetCell = annoteTarget.getAttribute("data-target-cell");
        const targetAnnotation = annoteTarget.getAttribute("data-target-annotation");
        const contentFn = () => {
          const content = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          if (content) {
            const tipContent = content.cloneNode(true);
            tipContent.classList.add("code-annotation-tip-content");
            return tipContent.outerHTML;
          }
        }
        const config = {
          allowHTML: true,
          content: contentFn,
          onShow: (instance) => {
            selectCodeLines(instance.reference);
            instance.reference.classList.add('code-annotation-active');
            window.tippy.hideAll();
          },
          onHide: (instance) => {
            unselectCodeLines();
            instance.reference.classList.remove('code-annotation-active');
          },
          maxWidth: 300,
          delay: [50, 0],
          duration: [200, 0],
          offset: [5, 10],
          arrow: true,
          appendTo: function(el) {
            return el.parentElement.parentElement.parentElement;
          },
          interactive: true,
          interactiveBorder: 10,
          theme: 'quarto',
          placement: 'right',
          popperOptions: {
            modifiers: [
            {
              name: 'flip',
              options: {
                flipVariations: false, // true by default
                allowedAutoPlacements: ['right'],
                fallbackPlacements: ['right', 'top', 'top-start', 'top-end', 'bottom', 'bottom-start', 'bottom-end', 'left'],
              },
            },
            {
              name: 'preventOverflow',
              options: {
                mainAxis: false,
                altAxis: false
              }
            }
            ]        
          }      
        };
        window.tippy(annoteTarget, config); 
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://giscus.app/client.js" data-repo="olivierbinette/olivierbinette.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkxNTk0Mzc2MjQ=" data-category="General" data-category-id="DIC_kwDOCYDTOM4CA7V-" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" async="">
</script>
<input type="hidden" id="giscus-base-theme" value="light">
<input type="hidden" id="giscus-alt-theme" value="dark">
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
 Copyright © 2024 Olivier Binette
  </li>  
</ul>
    </div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>